(ns brick.brick-test
  "Sample assembly for brick and ground."
  (:require [expectations :refer :all]
            [isis.geom.model
             [joint :refer [joint-primitive-map]]
             [graph :refer [make->link make->marker
                            port->expand
                            port-pair->make-constraint
                            graph->init-invariants
                            graph->expand-joint-pair ]]
             [invariant :refer [init-marker-invariant
                                init-graph-invariant
                                marker->add-invariant!
                                make->invariant]]]
            [isis.geom.action-dispatch
             :refer [precondition?
                     transform!
                     assert-postcondition!]]))


(def brick-graph
  "From section 3.4 : Example 1: the brick
  This object is composed of the prime data for an assembly.
  The derived data should not be stored in this object directly,
  but be stored in other objects with simliar keys."
  (ref
   { :links
     {  'brick  (make->link
                'brick
                :markers {'b1 (make->marker :p1 -100.0 :p2 50.0 :p3 10.0)
                          'b2 (make->marker :p1 -99.0 :p2 50.0 :p3 10.0)
                          'b3 (make->marker :p1 -100.0 :p2 51.0 :p3 10.0) }
                :ports {'j1 {:type :spherical :marker 'b1}
                        'j2 {:type :spherical :marker 'b2}
                        'j3 {:type :spherical :marker 'b3}} )
       'ground (make->link
                'ground
                :markers {'g1 (make->marker )
                          'g2 (make->marker :p1 1.0 :p2 0.0 :p3 0.0)
                          'g3 (make->marker :p1 0.0 :p2 1.0 :p3 0.0) }
                :ports {'j1 {:type :spherical :marker 'g1}
                        'j2 {:type :spherical :marker 'g2}
                        'j3 {:type :spherical :marker 'g3}}
                :invariant (make->invariant :p ['g1 'g2 'g3] ))}
     :joints
     #{#{['ground 'j1] ['brick 'j1]}
       #{['ground 'j2] ['brick 'j2]}
       #{['ground 'j3] ['brick 'j3]}} }))

(def brick-graph-goal
  "This shows the ultimate goal for the action-analysis.
  Notice that the ground has no properties, this idicates the
  use of the default values, it also indicates the 'base' object.
  In this example there is no rotation so the {:i1 :i2 :i3} values
  could be anything."
  {:link-motors
   {'ground {}
    'brick {:p1 100.0 :p2 -50.0 :p3 -10.0}}})


(declare graph->expand-joints graph->action-analysis)

(defn make-graph-watcher
  "This function is suitable to use as a watch function.
  When a graph changes it will compute the placement of
  each link in its assembly.  The augmented graph will
  be produced by this function."
  []
  (defn graph->assemble
    [key reference old-state new-state]
    (graph->expand-joints new-state))

  (add-watch brick-graph :assembly-key graph->assemble) )


(port->expand @brick-graph ['ground 'j1])

(port-pair->make-constraint @brick-graph
                            [['ground 'g2 :coincident {:p1 1.0, :p3 0.0, :p2 0.0}]
                             ['brick 'b2 :coincident {:p1 101.0, :p3 0.0, :p2 0.0}]] )


(graph->expand-joint-pair @brick-graph #{['ground 'j1] ['brick 'j1]})


(graph->init-invariants @brick-graph)


(defn graph->expand-joints
  "Using a graph's joint definitions,
  generate a list of constraints for the joint primitives.
  Each constraint primitive is generated by merging
  corresponding ports."
  [graph]
  (mapcat identity
          (for [joint-pair (:joints graph)]
            (graph->expand-joint-pair graph joint-pair))))

(expect ({:type :coincident,
          :m1 [['ground 'g2] {:p1 1.0, :p3 0.0, :p2 0.0}],
          :m2 [['brick 'b2] {:p1 -99.0, :p3 10.0, :p2 50.0}]}
         {:type :coincident,
          :m1 [['ground 'g3] {:p1 0.0, :p3 0.0, :p2 1.0}],
          :m2 [['brick 'b3] {:p1 -100.0, :p3 10.0, :p2 51.0}]}
         {:type :coincident,
          :m1 [['ground 'g1] {}],
          :m2 [['brick 'b1] {:p1 -100.0, :p3 10.0, :p2 50.0}]})
        (graph->expand-joints @brick-graph))


;; (clojure.pprint/pprint
(try
  (for [constraint (graph->expand-joints @brick-graph)
        :let [ {c-type :type m1 :m1 m2 :m2} constraint ] ]
    (str c-type m1 m2) )

  (catch IllegalStateException ex
    (println ex)))

brick-graph


(defn action-analysis
  "Algorithm for using the plan fragment table to perform action alalysis.
  We update a link map and a marker map with invariants.
  The link map of invariants indicates just how well placed the link is.
  The marker map does a similar thing.
  - We will repeatedly evaluate all constraints, making marker properties
  invariant and producing link motors, until no more constraints can be satisfied.
  The link motors are then returned.
  constraints : the list of constraints needing to be satisfied.
  invariants : invariant properties of markers and links.

  ys : constraints which have been tried and failed.
  progress? : is the current round making progress?"
  [constraints invariants]
  (loop [ [x & xs] constraints,
          ys [], progress? true]
    (if-not x
      (if (empty? ys)
        ;; all the constraints have been satisfied
        invariants
        (if progress?
          ;; still making progress, try again.
          (recur ys [] true)
          ;; no progress is possible.
          invariants))
      ;; working through the constraint list.
      (if (precondition? x invariants)
        (do
          (transform! x invariants)
          (recur xs ys true))
        (recur xs ys progress?) ))))


(try
  (let [graph @brick-graph
        constraints (graph->expand-joints graph)
        invariants (graph->init-invariants graph)]
    (action-analysis constraints invariants))
  (catch IllegalStateException ex
    (println ex)))
