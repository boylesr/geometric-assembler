(ns isis.geom.model.graph
 (:require [isis.geom.model
             [joint :refer [joint-primitive-map]]
             [invariant :refer [init-marker-invariant
                                init-graph-invariant
                                marker->add-invariant!
                                make->invariant]]]))


;; there are a set of named links.
;; each link has a set of joints.
;; each joint has a marker.
;; each joint has a set of constraints.
;; each link has a set of invarients.
;; each marker has a set of invarients.

(defn validate-graph
  "A function to validate the linkage graph."
  [g]
  true )

(defn make->link
  "Construct a geometric component, i.e. a link"
  [name & {:as opts}]
  (merge {:name name :markers {} :ports {} :invariant {}} opts))


(defn get-dof-key
  "Get the DoF key for the geometry."
  [link]

  )

(defn make->marker
  "Creates a marker in the appropriate coordinate frame."
  [& {:as opts}]
  (merge #_{:p1 0.0 :p2 0.0 :p3 0.0 :z1 0.0 :z2 0.0 :z3 0.0 :x1 0.0 :x2 0.0 :x3 0.0}
         {} opts))

(defn port->expand
  "Expand a single port into a vector of port-primitives."
  [graph [link-name port-name]]
  (let [links (:links graph)
        link (get links link-name)
        ports (:ports link)
        port (get ports port-name)
        primitive-types ((:type port) joint-primitive-map)
        port-marker-name (:marker port)
        markers (:markers link)
        port-marker (get markers port-marker-name)]
    (into [] (for [primitive-type primitive-types]
               [link-name port-marker-name primitive-type port-marker])) ) )


(defn port-pair->make-constraint
  "Using a graph's joint definitions,
  generate a list of constraints for the joint primitives.
  Each constraint primitive is generated by merging
  corresponding ports."
  [graph port-pair]
  (let [ [p1 p2] (seq port-pair)
         [p1-link p1-name p1-type p1-mark] p1
         [p2-link p2-name p2-type p2-mark] p2]
    (when (not= p1-type p2-type)
      (throw (IllegalStateException.
              (str "the connected joints have mismatched types : "
                   p1-type " != " p2-type)) ))
    {:type p1-type :m1 [[p1-link p1-name] p1-mark] :m2 [[p2-link p2-name] p2-mark]} ) )


(defn graph->expand-joint-pair
  "Using a joint definitions, generate a list of constraints for the joint's primitives.
  Each constraint primitive is generate by merging corresponding ports."
  [graph joint-pair]
  (let [ link (:links graph)
         constr-lists (for [[port-link port-joint] (seq joint-pair)]
                        (port->expand graph [port-link port-joint]))
         [c1-list c2-list] constr-lists
         con-pair-list (map vector c1-list c2-list)]
    (for [con-pair con-pair-list]
      (port-pair->make-constraint graph con-pair))))


(defn graph->init-invariants
  "Make the marker invariant map and
  extract all the initial marker invariants into it."
  [graph]
  (let [m (init-marker-invariant)
        g (init-graph-invariant)]
    (doseq [ [link-name link] (:links graph) ]
      (let [inv (:invariant link)
            pnt-inv (:p inv)]
        (when-not (empty? pnt-inv)
          (doseq [marker-name pnt-inv]
            (marker->add-invariant! m [link-name marker-name] :p)))))
    {:m m :g g}))
